// THIS FILE IS AUTOGENERATED, DO NOT EDIT IT!
// ############################################################################
// ## File         : i2c_slave_wb_master.sv
// ## Author       : Alessandro Caratelli (alessandro.caratelli@cern.ch)
// ############################################################################
// ## I2C slave - Wishbone Master
// ############################################################################

// This file is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties
// of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be
// liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or
// in connection with this file or the use or other dealings in the file. */

module i2c_slave_wb_master_rstb #(
    parameter  ADRLEN  = 1,                        // number of address bytes
    parameter  DATLEN  = 1,                        // number of data bytes
    parameter  TIMEOUT = 1023                      // timeout in clock cycles (if 0, no watchdog implemented)
    )(
    input  logic          [6:0] chip_addr_i,       // I2C Chip Address (7 bit mode)
    input  logic          [6:0] broadcast_addr_i,  // I2C general call Chip Address (7 bit mode)
    input  logic                clock,             // system clock (f_clk > 4*f_I2C)
    input  logic                rst_n,             // sync reset active low
    input  logic                i2c_scl_i,         // I2C SCL connect to pad input
    output logic                i2c_sda_o,         // I2C SDA connect to pad enable (enable if low)
    input  logic                i2c_sda_i,         // I2C SDA connect to pad input
    output logic [8*ADRLEN-1:0] wb_adr_o,          // wishbone address
    output logic                wb_wen_o,          // wishbone write enable
    output logic                wb_stb_o,          // wishbone strobe
    output logic                wb_cyc_o,          // wishbone cycle
    input  logic                wb_ack_i,          // wishbone acknoledge
    input  logic [8*DATLEN-1:0] wb_dat_i,          // wishbone data from slave to master
    output logic [8*DATLEN-1:0] wb_dat_o,          // wishbone data from master to slave
    output logic                enable_o,          // enable flag
    output logic                err_wb_adr_o       // notify not-acknoledge wb operation
    );

    // tmrg default triplicate

    localparam CNTSIZE = (DATLEN>ADRLEN) ? ((DATLEN>=2)?DATLEN:2) : ((ADRLEN>=2)?ADRLEN:2);
    localparam [2:0] IDLE=3'd0, ADRI2C=3'd1, WBADRRX=3'd2, WBDATRX=3'd3, WBDATTX=3'd4;

    reg   start, stop, close_del, close_d, err_wb_adr_od;
    reg   sclc, sdac, sda_del, scl_del;
    reg   i2c_sda_od, wb_wen_od, wb_stb_od, enable_d;
    wire  close, scl_posedge, scl_negedge;

    reg                   [2:0] state;
    reg                   [3:0] idx;
    reg        [(DATLEN*8)-1:0] buffer;
    reg   [$clog2(CNTSIZE)-1:0] cyclecnt;
    reg   [$clog2(TIMEOUT)-1:0] timeoutcnt;
    reg          [8*ADRLEN-1:0] wb_adr_od, wb_adr_f;
    reg          [8*DATLEN-1:0] wb_dat_od, wb_dat_f;
    reg                         scl_sd1, scl_sd2, sda_sd1, sda_sd2;

    // TMR Voted INPUT signals
    wire                        wb_ack_iVoted         = wb_ack_i;
    wire         [8*DATLEN-1:0] wb_dat_iVoted         = wb_dat_i;
    wire                  [6:0] chip_addr_iVoted      = chip_addr_i;
    wire                  [6:0] broadcast_addr_iVoted = broadcast_addr_i;

    // TMR Voted internal registers
    wire                  [2:0] stateVoted          = state;
    wire                  [3:0] idxVoted              = idx;
    wire       [(DATLEN*8)-1:0] bufferVoted         = buffer;
    wire                        startVoted          = start;
    wire                        stopVoted           = stop;
    wire                        close_delVoted      = close_del;
    wire                        sclcVoted           = sclc;
    wire                        sdacVoted           = sdac;
    wire                        sda_delVoted        = sda_del;
    wire                        scl_delVoted        = scl_del;
    wire  [$clog2(CNTSIZE)-1:0] cyclecntVoted       = cyclecnt;
    wire  [$clog2(TIMEOUT)-1:0] timeoutcntVoted     = timeoutcnt;
    wire                        close_dVoted        = close_d;
    wire         [8*DATLEN-1:0] wb_dat_odVoted      = wb_dat_od;
    wire         [8*ADRLEN-1:0] wb_adr_odVoted      = wb_adr_od;

    // TMR Voted OUTPUT signals
    wire                        i2c_sda_odVoted     = i2c_sda_od;
    wire         [8*ADRLEN-1:0] wb_adr_fVoted       = wb_adr_f;
    wire                        wb_wen_odVoted      = wb_wen_od;
    wire                        wb_stb_odVoted      = wb_stb_od;
    wire         [8*DATLEN-1:0] wb_dat_fVoted       = wb_dat_f;
    wire                        enable_dVoted       = enable_d;
    wire                        err_wb_adr_odVoted  = err_wb_adr_od;
    wire                        sda_sd2Voted        = sda_sd2;
    wire                        scl_sd2Voted        = scl_sd2;

    // Voted output signals assignments
    assign wb_cyc_o     = wb_stb_odVoted;
    assign wb_stb_o     = wb_stb_odVoted;
    assign i2c_sda_o    = i2c_sda_odVoted;
    assign wb_adr_o     = wb_adr_fVoted;
    assign wb_wen_o     = wb_wen_odVoted;
    assign wb_dat_o     = wb_dat_fVoted;
    assign enable_o     = enable_dVoted;
    assign err_wb_adr_o = err_wb_adr_odVoted;
    assign scl_posedge  = ~scl_delVoted & sclcVoted;
    assign scl_negedge  = scl_delVoted & ~sclcVoted;


    always_ff @(posedge clock) begin
        if(!rst_n) begin
            scl_sd1 <= 1'b1;
            scl_sd2 <= 1'b1;
            sda_sd1 <= 1'b1;
            sda_sd2 <= 1'b1;
        end
        else begin
            scl_sd1 <= i2c_scl_i;
            scl_sd2 <= scl_sd1;
            sda_sd1 <= i2c_sda_i;
            sda_sd2 <= sda_sd1;
        end
    end


    always_ff @(posedge clock) begin
        if(!rst_n) begin

            sclc      <= 1'b1;
            scl_del   <= 1'b1;
            sdac      <= 1'b1;
            sda_del   <= 1'b1;
        end
        else begin
            sclc      <=   scl_sd2Voted;
            scl_del   <=   sclcVoted;
            sdac      <=   sda_sd2Voted;
            sda_del   <=   sdacVoted;
        end
    end

    always_ff @(posedge clock) begin: get_start_condition
        if(!rst_n) begin
            start <=   1'b0;
        end
        else begin
            if(sclcVoted & ~sdacVoted & sda_delVoted)
                start <=   1'b1;
            else
                start <=   1'b0;
        end
    end


    always_ff @(posedge clock) begin: get_stop_condition
        if(!rst_n) begin
            stop <=   1'b0;
        end
        else begin
            if(sclcVoted & sdacVoted & ~sda_delVoted)
                stop <=   1'b1;
            else
                stop <=   1'b0;
        end
    end


    always_ff @(posedge clock) begin: enable_logic
        if(!rst_n) begin
            enable_d <=   1'b0;
        end
        else begin
            if (startVoted)
                enable_d <=   1'b1;
            else begin
                if (stopVoted || close_delVoted)
                    enable_d <=   1'b0;
                else
                    enable_d <=   enable_dVoted;
            end
        end
    end

    always_comb begin: handle_sda
        if(!enable_dVoted) begin
            i2c_sda_od = 1'b1;
        end
        else begin
            casez({stateVoted, idxVoted})
                {ADRI2C, 4'd9}: begin
                                    if(wb_dat_odVoted[7:1] == chip_addr_iVoted)
                                        i2c_sda_od =  1'b0; // ack for read/write operations
                                    else if (wb_dat_odVoted[7:1] == broadcast_addr_iVoted)
                                        i2c_sda_od =  (~wb_dat_odVoted[0]) ? 1'b0 : 1'b1; // ack only for write operations
                                    else
                                        i2c_sda_od =  1'b1;
                                end
                {WBADRRX,4'd8}:    i2c_sda_od = 1'b0;
                {WBDATRX,4'd8}:    i2c_sda_od = 1'b0;
                {WBDATTX,4'b0???}: i2c_sda_od = bufferVoted[(8*DATLEN)-1];
                default:           i2c_sda_od = 1'b1;
            endcase
        end
    end

    always_ff @(posedge clock) begin: wb_strobe
        if(!rst_n) begin

            wb_stb_od <=   1'b0;
            wb_wen_od <=   1'b0;
            wb_adr_f  <=  'b0;
            wb_dat_f  <=  'b0;
            err_wb_adr_od <= 1'b0;
        end
        else begin
            // default condition takes voted value
            wb_wen_od <=   wb_wen_odVoted;
            wb_stb_od <=   wb_stb_odVoted;
            wb_adr_f  <=   wb_adr_fVoted;
            wb_dat_f  <=   wb_dat_fVoted;
            err_wb_adr_od <= 1'b0;
            if (stopVoted || startVoted || close) begin
                wb_stb_od <= 1'b0;
                wb_wen_od <= 1'b0;
                wb_dat_f <= 'b0;
                wb_adr_f <= 'b0;
                err_wb_adr_od <=  (wb_stb_odVoted) ? 1'b1 : 1'b0;
            end
            else if(wb_ack_iVoted) begin
                wb_stb_od <=   1'b0; //clear the strobe after the acknoledge from the wb slave
            end
            else begin
                case (stateVoted)
                    IDLE:  begin
                        wb_stb_od <= 1'b0;
                        wb_wen_od <= 1'b0;
                        wb_dat_f <= 'b0;
                        wb_adr_f <= 'b0;
                        err_wb_adr_od <=  (wb_stb_odVoted) ? 1'b1 : 1'b0;
                    end
                    WBDATRX: begin
                        if ( (cyclecntVoted==(DATLEN-1)) && (idxVoted==4'd7) && scl_negedge ) begin
                            wb_stb_od <=   1'b1; //give a strobe to read the data
                            wb_adr_f <=  wb_adr_odVoted;
                            wb_dat_f <=  wb_dat_odVoted;
                            wb_wen_od <=   1'b1;
                        end
                        else if( (cyclecntVoted>=(DATLEN-1)) && (idxVoted==4'd8) && scl_posedge) begin
                            wb_stb_od <=   1'b0; //handle missing ack due to read on not existing wb_slave
                            err_wb_adr_od <=  (wb_stb_odVoted) ? 1'b1 : 1'b0;
                        end
                    end
                    WBDATTX: begin
                        wb_wen_od <=   1'b0;
                        if((cyclecntVoted==(DATLEN-1)) && (idxVoted==4'd8) && scl_negedge) begin
                            wb_stb_od <=   1'b1; //give a strobe to read the data
                            wb_adr_f <=  wb_adr_odVoted;
                            wb_dat_f <=  'h0;
                        end
                        else if((cyclecntVoted>=(DATLEN-1)) && (idxVoted==4'd8) && scl_posedge) begin
                            wb_stb_od <=   1'b0; //handle missing ack due to write on not existing wb_slave
                            err_wb_adr_od <=  (wb_stb_odVoted) ? 1'b1 : 1'b0;
                        end
                    end
                    ADRI2C: begin
                        wb_wen_od <=   1'b0;
                        if ((wb_dat_odVoted[0]) && (cyclecntVoted==0) && scl_negedge) begin
                            if((idxVoted==4'd8) && (wb_dat_odVoted[7:1] == chip_addr_iVoted)) begin
                                wb_stb_od <=   1'b1; //give a strobe to read the data
                                wb_adr_f <=  wb_adr_odVoted;
                                wb_dat_f <=  'h0;
                            end
                            else if(idxVoted==4'd9) begin
                                wb_stb_od <=   1'b0;
                                err_wb_adr_od <=  (wb_stb_odVoted) ? 1'b1 : 1'b0;
                            end
                        end
                    end
                endcase
            end
        end
    end


    always_ff @(posedge clock) begin: i2c_fsm
        if(!rst_n) begin

            state     <=   IDLE;
            idx       <=   4'b0;
            wb_adr_od <=  16'b0;
            wb_dat_od <=   8'b0;
            cyclecnt  <=   1'b0;
            buffer    <=   8'b0;
        end
        else begin
            state     <=   stateVoted;
            idx       <=   idxVoted;
            wb_adr_od <=   wb_adr_odVoted;
            wb_dat_od <=   wb_dat_odVoted;
            cyclecnt  <=   cyclecntVoted;
            buffer    <=   bufferVoted;

            if (startVoted) begin
                state     <=   ADRI2C;
                idx       <=   4'b0;
                wb_dat_od <=   8'b0;
                cyclecnt  <=   1'b0;
                buffer    <=   8'b0;
            end
            else if (stopVoted | close | !enable_dVoted) begin
                state <=   IDLE;
                wb_dat_od <=    8'b0;
            end
            else case (stateVoted)

                IDLE: begin
                    state     <=   IDLE;
                    idx       <=   4'b0;
                    wb_dat_od <=   8'b0;
                    cyclecnt  <=   1'b0;
                    buffer    <=   8'b0;
                end

                ADRI2C: begin //st_ADR
                    idx <=   (scl_negedge) ? (idxVoted+4'b1) : idxVoted;
                    if (idxVoted<9 && scl_posedge) begin
                            wb_dat_od[7:0] <=   {wb_dat_odVoted[6:0], sdacVoted};
                            //reuse the wb_dat_od buffer to save registers
                    end
                    else if(idxVoted==9) begin
                        if (scl_negedge) begin
                            if((wb_dat_odVoted[7:1] != chip_addr_iVoted) && (wb_dat_odVoted[7:1] != broadcast_addr_iVoted))
                                state <=   IDLE;
                            else begin
                                if (wb_dat_odVoted[0]) begin
                                    state <= (wb_dat_odVoted[7:1] == chip_addr_iVoted) ? WBDATTX : IDLE;
                                    wb_adr_od <=   wb_adr_odVoted + 1'b1;
                                end
                                else begin
                                    state <= WBADRRX;
                                    wb_adr_od <=   wb_adr_odVoted;
                                end
                                idx <=   0;
                                cyclecnt <=   {$clog2(CNTSIZE){1'b0}};
                            end
                        end
                        if (wb_ack_iVoted & wb_dat_odVoted[0]) begin
                            buffer <=   wb_dat_iVoted;
                        end
                    end
                end

                WBADRRX: begin //st_WBADRRX
                    idx <=   (scl_negedge) ? (idxVoted+4'b1) : idxVoted;
                    if (idxVoted<8 && scl_posedge) begin
                            wb_adr_od <=   {wb_adr_odVoted, sdacVoted};
                    end
                    else if(idxVoted==8 && scl_negedge) begin
                        idx <=   0;
                        if (cyclecntVoted >= (ADRLEN-1)) begin
                            cyclecnt <=   {$clog2(CNTSIZE){1'b0}};
                            state <=   WBDATRX;
                        end
                        else cyclecnt <=   cyclecntVoted + 1'b1;
                    end
                end

                WBDATRX: begin //st_WBDATRX
                    idx <=   (scl_negedge) ? (idxVoted+4'b1) : idxVoted;
                    if (idxVoted<8 && scl_posedge) begin
                            wb_dat_od <=   {wb_dat_odVoted, sdacVoted};
                    end
                    else if(idxVoted==8 && scl_negedge) begin
                        idx <=   0;
                        if (cyclecntVoted >= (DATLEN-1)) begin
                            cyclecnt <=   0;
                            wb_adr_od <=   wb_adr_odVoted + 1'b1;
                        end
                        else cyclecnt <=   cyclecntVoted + 1'b1;
                    end
                end

                WBDATTX: begin //st_WBDATTX
                    idx <=   (scl_negedge) ? (idxVoted+4'b1) : idxVoted;
                    if (idxVoted<8 && scl_negedge) begin
                            buffer <=   bufferVoted << 1;
                    end
                    else if(idxVoted==8) begin
                        if (scl_posedge && sdacVoted) begin //no_ack
                            state <=   IDLE;
                        end
                        else if (scl_negedge) begin
                            idx <=   0;
                            if (cyclecntVoted >= (DATLEN-1)) begin
                                cyclecnt <=   0;
                                wb_adr_od <=   wb_adr_odVoted + 1'b1;
                            end
                            else cyclecnt <=   cyclecntVoted + 1'b1;
                        end
                    end
                    else if((idxVoted==0) && wb_ack_iVoted) begin
                        buffer <=   wb_dat_iVoted;
                    end
                end

                default: state <=   IDLE;

            endcase
        end
    end //i2c_fsm

    assign close = (timeoutcntVoted==0);


    always_ff @(posedge clock) begin: timeout_fsm
        if(!rst_n) begin

            timeoutcnt <=   TIMEOUT;
        end
        else begin
            if( (scl_delVoted==sclcVoted) && (sda_delVoted==sdacVoted) && enable_dVoted)
                timeoutcnt <=   timeoutcntVoted-1;
            else
                timeoutcnt <=   TIMEOUT;
        end
    end


    always_ff @(posedge clock) begin: close_fsm
        if(!rst_n) begin

            close_d   <=   1'b0;
            close_del <=   1'b0;
        end
        else begin
            close_d <=   close;
            close_del <=   close_dVoted;
        end
    end

endmodule
